{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://github.com/teamhanko/hanko/backend/v2/config/config",
  "$ref": "#/$defs/Config",
  "$defs": {
    "Account": {
      "properties": {
        "allow_deletion": {
          "type": "boolean",
          "description": "`allow_deletion` determines whether users can delete their accounts.",
          "default": false
        },
        "allow_signup": {
          "type": "boolean",
          "description": "`allow_signup` determines whether users are able to create new accounts.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "AttributeMap": {
      "properties": {
        "name": {
          "type": "string",
          "default": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name"
        },
        "family_name": {
          "type": "string",
          "default": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname"
        },
        "given_name": {
          "type": "string",
          "default": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname"
        },
        "middle_name": {
          "type": "string"
        },
        "nickname": {
          "type": "string"
        },
        "preferred_username": {
          "type": "string"
        },
        "profile": {
          "type": "string"
        },
        "picture": {
          "type": "string"
        },
        "website": {
          "type": "string"
        },
        "gender": {
          "type": "string"
        },
        "birthdate": {
          "type": "string"
        },
        "zone_info": {
          "type": "string"
        },
        "locale": {
          "type": "string"
        },
        "updated_at": {
          "type": "string"
        },
        "email": {
          "type": "string",
          "default": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress"
        },
        "email_verified": {
          "type": "string"
        },
        "phone": {
          "type": "string"
        },
        "phone_verified": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "AuditLog": {
      "properties": {
        "console_output": {
          "$ref": "#/$defs/AuditLogConsole",
          "title": "console_output",
          "description": "`console_output` controls audit log console output."
        },
        "mask": {
          "type": "boolean",
          "description": "`mask` determines whether sensitive information (usernames, emails) should be masked in the audit log output.\n\nThis configuration applies to logs written to the console as well as persisted logs.",
          "default": true
        },
        "storage": {
          "$ref": "#/$defs/AuditLogStorage",
          "description": "`storage` controls audit log retention."
        },
        "retention": {
          "type": "string",
          "description": "`retention` specifies the time duration after which log audit entries may be deleted.",
          "default": "720h"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "AuditLogConsole": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` controls whether audit log output on the console is enabled or disabled.",
          "default": true
        },
        "output": {
          "type": "string",
          "enum": [
            "stdout",
            "stderr"
          ],
          "description": "`output` determines the output stream audit logs are sent to.",
          "default": "stdout"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "AuditLogStorage": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` controls whether audit log should be retained (i.e. persisted).",
          "default": false
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Config": {
      "properties": {
        "account": {
          "$ref": "#/$defs/Account",
          "title": "account",
          "description": "`account` configures settings related to user accounts."
        },
        "audit_log": {
          "$ref": "#/$defs/AuditLog",
          "title": "audit_log",
          "description": "`audit_log` configures output and storage modalities of audit logs."
        },
        "convert_legacy_config": {
          "type": "boolean",
          "description": "`convert_legacy_config`, if set to `true`, automatically copies the set values of deprecated configuration\noptions, to new ones. If set to `false`, these values have to be set manually if non-default values should be\nused.",
          "default": false
        },
        "convert_legacy_server_side_session_config": {
          "type": "boolean",
          "description": "`covert_legacy_session_config`, if set to `true`, automatically copies the set of deprecated server-side session\nconfiguration options to the new ones. If set to `false`, these values have to be set manually if non-default\nvalues should be used.",
          "default": true
        },
        "database": {
          "$ref": "#/$defs/Database",
          "title": "database",
          "description": "`database` configures database connection settings."
        },
        "debug": {
          "type": "boolean",
          "description": "`debug`, if set to `true`, adds additional debugging information to flow API responses.",
          "default": false
        },
        "email": {
          "$ref": "#/$defs/Email",
          "title": "email",
          "description": "`email` configures how email addresses of user accounts are acquired and used."
        },
        "email_delivery": {
          "$ref": "#/$defs/EmailDelivery",
          "title": "email_delivery",
          "description": "`email_delivery` configures how outgoing mails are delivered."
        },
        "emails": {
          "$ref": "#/$defs/Emails",
          "title": "emails",
          "description": "Deprecated. See child properties for suggested replacements."
        },
        "flow_locker": {
          "$ref": "#/$defs/FlowLocker",
          "description": "`flow_locker` confgures flow locking"
        },
        "log": {
          "$ref": "#/$defs/LoggerConfig",
          "title": "log",
          "description": "`log` configures application logging."
        },
        "mfa": {
          "$ref": "#/$defs/MFA",
          "title": "mfa",
          "description": "`mfa` configures how multi-factor-authentication behaves."
        },
        "passcode": {
          "$ref": "#/$defs/Passcode",
          "title": "passcode",
          "description": "Deprecated. See child properties for suggested replacements."
        },
        "passkey": {
          "$ref": "#/$defs/Passkey",
          "title": "passkey",
          "description": "`passkey` configures how passkeys  are acquired and used."
        },
        "password": {
          "$ref": "#/$defs/Password",
          "title": "password",
          "description": "`password` configures how passwords are acquired and used."
        },
        "rate_limiter": {
          "$ref": "#/$defs/RateLimiter",
          "title": "rate_limiter",
          "description": "`rate_limiter` configures rate limits for rate limited API operations and storage modalities for rate limit data."
        },
        "saml": {
          "$ref": "#/$defs/Saml",
          "title": "saml",
          "description": "`saml` configures modalities of SAML (Security Assertion Markup Language) SSO authentication and SAML identity\nproviders."
        },
        "secrets": {
          "$ref": "#/$defs/Secrets",
          "title": "secrets",
          "description": "`secrets` configures the keys used for cryptographically signing tokens issued by the API."
        },
        "security_notifications": {
          "$ref": "#/$defs/SecurityNotifications",
          "description": "`security_notifications` configures security notifications for important security-related events."
        },
        "server": {
          "$ref": "#/$defs/Server",
          "title": "server",
          "description": "`server` configures address and CORS settings of the public and admin API."
        },
        "service": {
          "$ref": "#/$defs/Service",
          "title": "service",
          "description": "`service` configures general service information."
        },
        "session": {
          "$ref": "#/$defs/Session",
          "title": "session",
          "description": "`session` configures settings for session JWTs and Cookies issued by the API."
        },
        "smtp": {
          "$ref": "#/$defs/SMTP",
          "title": "smtp",
          "description": "Deprecated. Use `email_delivery.smtp` instead."
        },
        "third_party": {
          "$ref": "#/$defs/ThirdParty",
          "title": "third_party",
          "description": "`third_party` configures the modalities of third party OAuth/OIDC based authentication and available identity\nproviders."
        },
        "username": {
          "$ref": "#/$defs/Username",
          "title": "username",
          "description": "`username` configures how usernames of user accounts are acquired and used."
        },
        "webauthn": {
          "$ref": "#/$defs/WebauthnSettings",
          "title": "webauthn",
          "description": "`webauthn` configures general settings for communication with the WebAuthentication API."
        },
        "webhooks": {
          "$ref": "#/$defs/WebhookSettings",
          "title": "webhooks",
          "description": "`webhooks` configures HTTP-based callbacks for specific events occurring in the system."
        },
        "privacy": {
          "$ref": "#/$defs/Privacy",
          "title": "privacy",
          "description": "`privacy` configures privacy settings"
        },
        "multi_tenant": {
          "$ref": "#/$defs/MultiTenant",
          "title": "multi_tenant",
          "description": "`multi_tenant` configures multi-tenant mode for tenant-scoped user isolation."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "Config is the central configuration type"
    },
    "Cookie": {
      "properties": {
        "domain": {
          "type": "string",
          "description": "`domain` is the domain the cookie will be bound to. Works for subdomains, but not cross-domain.\nSee the `session.enable_auth_token_header` configuration instead if the API and the client application run on\ndifferent domains.",
          "default": "hanko"
        },
        "http_only": {
          "type": "boolean",
          "description": "`http_only` determines whether cookies are HTTP only or accessible by Javascript.",
          "default": true
        },
        "name": {
          "type": "string",
          "description": "`name` is the name of the cookie.",
          "default": "hanko"
        },
        "retention": {
          "type": "string",
          "enum": [
            "session",
            "persistent",
            "prompt"
          ],
          "description": "`retention` determines the retention behavior of authentication cookies.",
          "default": "persistent",
          "meta:enum": {
            "persistent": "Issues a cookie that remains stored on the user's device until it reaches its expiration date.",
            "prompt": "Allows the user to choose whether to stay signed in. If the user selects 'Stay signed in', a persistent cookie is issued; a session cookie otherwise.",
            "session": "Issues a temporary cookie that lasts for the duration of the browser session."
          }
        },
        "same_site": {
          "type": "string",
          "enum": [
            "strict",
            "lax",
            "none"
          ],
          "description": "`same_site` controls whether a cookie is sent with cross-site requests.\nSee [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value) for\nmore details.",
          "default": "strict"
        },
        "secure": {
          "type": "boolean",
          "description": "`secure` indicates whether the cookie is sent to the server only when a request is made with the https: scheme\n(except on localhost).\n\nNOTE: `secure` must be set to `false` when working on `localhost` and with the Safari browser because it does\nnot store secure cookies on `localhost`.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Cors": {
      "properties": {
        "allow_origins": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "allow_origins",
          "description": "`allow_origins` determines the value of the Access-Control-Allow-Origin\nresponse header. This header defines a list of [origins](https://developer.mozilla.org/en-US/docs/Glossary/Origin)\nthat may access the resource.\n\nThe wildcard characters `*` and `?` are supported and are converted to regex fragments `.*` and `.` accordingly.",
          "default": [
            "http://localhost:8888"
          ]
        },
        "unsafe_wildcard_origin_allowed": {
          "type": "boolean",
          "title": "unsafe_wildcard_origin_allowed",
          "description": "`unsafe_wildcard_origin_allowed` allows a wildcard `*` origin to be used with AllowCredentials\nflag. In that case we consider any origin allowed and send it back to the client in an `Access-Control-Allow-Origin` header.\n\nThis is INSECURE and potentially leads to [cross-origin](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\nattacks. See also https://github.com/labstack/echo/issues/2400 for discussion on the subject.\n\nOptional. Default value is `false`.",
          "default": false
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CustomThirdPartyProvider": {
      "if": {
        "properties": {
          "enabled": {
            "anyOf": [
              {
                "const": false
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "then": {},
      "else": {
        "if": {
          "properties": {
            "use_discovery": {
              "anyOf": [
                {
                  "const": false
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        "then": {
          "required": [
            "authorization_endpoint",
            "token_endpoint",
            "userinfo_endpoint"
          ]
        },
        "else": {
          "required": [
            "issuer"
          ]
        },
        "required": [
          "display_name",
          "client_id",
          "secret",
          "scopes"
        ]
      },
      "properties": {
        "acr_values": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "`acr_values` is a list of strings that specifies the Authentication Context Class Reference values that the\nAuthorization Server is being requested to use for processing this Authentication Request."
        },
        "allow_linking": {
          "type": "boolean",
          "description": "`allow_linking` indicates whether existing accounts can be automatically linked with this provider.\n\nLinking is based on matching one of the email addresses of an existing user account with the (primary)\nemail address of the third party provider account.",
          "default": false
        },
        "attribute_mapping": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "`attribute_mapping` defines a map that associates a set of known standard OIDC conformant end-user claims\n(the key of a map entry) at the Hanko backend to claims retrieved from a third party provider (the value of the\nmap entry). This is primarily necessary if a non-OIDC provider is configured/used in which case it is probable\nthat user data returned from the userinfo endpoint does not already conform to OIDC standard claims.\n\nExample: You configure an OAuth Provider (i.e. non-OIDC) and the provider's configured userinfo endpoint returns\nan end-user's user ID at the provider not under a `sub` key in its JSON response but rather under a `user_id`\nkey. You would then configure an attribute mapping as follows:\n\n```yaml\nattribute_mapping:\n sub: user_id\n```\n\nSee https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims for a list of known standard claims\nthat provider claims can be mapped into. Any other claims received from a provider are not discarded but are\nretained internally in a `custom_claims` claim.\n\nMappings are one-to-one mappings, complex mappings (e.g. mapping concatenations of two claims) are not possible."
        },
        "authorization_endpoint": {
          "type": "string",
          "description": "URL of the provider's authorization endpoint where the end-user is redirected to authenticate and grant consent for\nan application to access their resources.\n\nRequired if `use_discovery` is false or omitted."
        },
        "issuer": {
          "type": "string",
          "description": "`issuer` is the provider's issuer identifier. It should be a URL that uses the \"https\"\n\tscheme and has no query or fragment components.\n\nRequired if `use_discovery` is true."
        },
        "client_id": {
          "type": "string",
          "description": "`client_id` is the ID of the OAuth/OIDC client. Must be obtained from the provider.\n\nRequired if the provider is `enabled`."
        },
        "display_name": {
          "type": "string",
          "description": "`display_name` is the name of the provider that is intended to be shown to an end-user.\n\nRequired if the provider is `enabled`."
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` indicates if the provider is enabled or disabled.",
          "default": false
        },
        "prompt": {
          "type": "string",
          "description": "`prompt` specifies whether the Authorization Server prompts the End-User for reauthentication and consent.\nPossible values are:\n- login\n- none\n- consent\n- select_account\nPlease note that not all providers support all values. Check the corresponding docs of the provider for supported values."
        },
        "scopes": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "`scopes` is a list of scopes requested from the provider that specify the level of access an application has to\na user's resources on a server, defining what actions the app can perform on behalf of the user.\n\nRequired if the provider is `enabled`."
        },
        "secret": {
          "type": "string",
          "description": "`secret` is the client secret for the OAuth/OIDC client. Must be obtained from the provider.\n\nRequired if the provider is `enabled`."
        },
        "token_endpoint": {
          "type": "string",
          "description": "URL of the provider's token endpoint URL where an application exchanges an authorization code for an access\ntoken, which is used to authenticate API requests on behalf of the end-user.\n\nRequired if `use_discovery` is false or omitted."
        },
        "use_discovery": {
          "type": "boolean",
          "description": "`use_discovery` determines if configuration information about an OpenID Connect (OIDC) provider, such as\nendpoint URLs and supported features,should be automatically retrieved, from a well-known\nURL (typically /.well-known/openid-configuration).",
          "default": true
        },
        "userinfo_endpoint": {
          "type": "string",
          "description": "URL of the provider's endpoint that returns claims about an authenticated end-user.\n\nRequired if `use_discovery` is false or omitted."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "custom_provider"
    },
    "CustomThirdPartyProviders": {
      "additionalProperties": {
        "$ref": "#/$defs/CustomThirdPartyProvider"
      },
      "type": "object"
    },
    "Database": {
      "properties": {
        "database": {
          "type": "string",
          "description": "`database` determines the name of the database schema to use.",
          "default": "hanko"
        },
        "dialect": {
          "type": "string",
          "enum": [
            "postgres",
            "mysql",
            "mariadb",
            "cockroach"
          ],
          "description": "`dialect` is the name of the database system to use.",
          "default": "postgres"
        },
        "host": {
          "type": "string",
          "description": "`host` is the host the database system is running on.",
          "default": "localhost"
        },
        "password": {
          "type": "string",
          "description": "`password` is the password for the database user to use for connecting to the database.",
          "default": "hanko"
        },
        "port": {
          "type": "string",
          "description": "`port` is the port the database system is running on.",
          "default": "5432"
        },
        "url": {
          "type": "string",
          "description": "`url` is a datasource connection string. It can be used instead of the rest of the database configuration\noptions. If this `url` is set then it is prioritized, i.e. the rest of the options, if set, have no effect.\n\nSchema: `dialect://username:password@host:port/database`",
          "examples": [
            "postgres://hanko:hanko@localhost:5432/hanko"
          ]
        },
        "user": {
          "type": "string",
          "description": "`user` is the database user to use for connecting to the database.",
          "default": "hanko"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Email": {
      "properties": {
        "acquire_on_login": {
          "type": "boolean",
          "description": "`acquire_on_login` determines whether users, provided that they do not already have registered an email,\n\tare prompted to provide an email on login.",
          "default": false
        },
        "acquire_on_registration": {
          "type": "boolean",
          "description": "`acquire_on_registration` determines whether users are prompted to provide an email on registration.",
          "default": true
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether emails are enabled.",
          "default": true
        },
        "limit": {
          "type": "integer",
          "description": "'limit' determines the maximum number of emails a user can register.",
          "default": 5
        },
        "max_length": {
          "type": "integer",
          "description": "`max_length` specifies the maximum allowed length of an email address.",
          "default": 100
        },
        "optional": {
          "type": "boolean",
          "description": "`optional` determines whether users must provide an email when prompted.\nThere must always be at least one email address associated with an account. The primary email address cannot be\ndeleted if emails are required (`optional`: false`).",
          "default": false
        },
        "passcode_ttl": {
          "type": "integer",
          "description": "`passcode_ttl` specifies, in seconds, how long a passcode is valid for.",
          "default": 300
        },
        "passcode_charset": {
          "type": "string",
          "enum": [
            "numeric",
            "alphanumeric"
          ],
          "description": "`passcode_charset` specifies the characters that can be used in passcodes.\nE.g. `numeric` allows only numbers, `alphanumeric` allows both numbers and letters.",
          "default": "numeric"
        },
        "require_verification": {
          "type": "boolean",
          "description": "`require_verification` determines whether newly created emails must be verified by providing a passcode sent\nto respective address.",
          "default": true
        },
        "use_as_login_identifier": {
          "type": "boolean",
          "description": "`use_as_login_identifier` determines whether emails can be used as an identifier on login.",
          "default": true
        },
        "use_for_authentication": {
          "type": "boolean",
          "description": "`user_for_authentication` determines whether users can log in by providing an email address and subsequently\nproviding a passcode sent to the given email address.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "EmailDelivery": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether the API delivers emails.\nDisable if you want to send the emails yourself. To do so you must subscribe to the `email.create` webhook event.",
          "default": true
        },
        "from_address": {
          "type": "string",
          "description": "`from_address` configures the sender address of emails sent to users.",
          "default": "noreply@hanko.io"
        },
        "from_name": {
          "type": "string",
          "description": "`from_name` configures the sender name of emails sent to users.",
          "default": "Hanko"
        },
        "smtp": {
          "$ref": "#/$defs/SMTP",
          "title": "smtp",
          "description": "`SMTP` contains the SMTP server settings for sending mails."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Emails": {
      "properties": {
        "require_verification": {
          "type": "boolean",
          "description": "Deprecated. Use `email.require_verification` instead.",
          "default": true
        },
        "max_num_of_addresses": {
          "type": "integer",
          "description": "Deprecated. Use `email.limit` instead.",
          "default": 5
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Events": {
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "FlowLocker": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` controls whether flow locking is enabled",
          "default": true
        },
        "store": {
          "type": "string",
          "enum": [
            "in_memory",
            "redis"
          ],
          "description": "`store` sets the backend for the flow locker",
          "default": "in_memory"
        },
        "redis_config": {
          "$ref": "#/$defs/RedisConfig",
          "description": "`redis_config` configures connection to a redis instance\nRequired if `store` is set to `redis`"
        },
        "ttl": {
          "type": "string",
          "description": "`ttl` is the lock timeout (for Redis only)",
          "default": "30s"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "IdentityProvider": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` activates or deactivates the identity provider.",
          "default": false
        },
        "name": {
          "type": "string",
          "description": "`name` is the name given for the identity provider."
        },
        "domain": {
          "type": "string",
          "description": "At login the domain will be extracted from the users email address and then used to identify the idp to use.\nThis tag defines for which domain the idp is used."
        },
        "metadata_url": {
          "type": "string",
          "description": "`metadata_url` is the URL the API can retrieve IdP metadata from."
        },
        "skip_email_verification": {
          "type": "boolean",
          "description": "`skip_email_verification` determines whether the check if the `email_verified` attribute in the IdP response\nwill be skipped."
        },
        "attribute_map": {
          "$ref": "#/$defs/AttributeMap",
          "title": "attribute_map",
          "description": "`attribute_map` is a map of attributes used to map attributes in IdP response to custom attributes at\nHanko."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "JWTTemplate": {
      "properties": {
        "claims": {
          "type": "object"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "KeyManagement": {
      "if": {
        "properties": {
          "type": {
            "const": "aws_kms"
          }
        }
      },
      "then": {
        "required": [
          "key_id",
          "region"
        ]
      },
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "local",
            "aws_kms"
          ],
          "description": "Type specifies the key management system to use. Supported values are 'local' (default) for local key storage\nor 'aws_kms' for AWS Key Management Service.\nWhen using 'aws_kms,' the AWS credentials must be set using the standard AWS credential chain (in order of precedence).\n1. Environment variables (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN)\n2. Shared credentials file (~/.aws/credentials)\n3. Shared config file (~/.aws/config)\n4. IAM role for Amazon EC2 (via instance metadata service)\n5. IAM role for Amazon ECS (via container credentials)\n6. IAM role for Amazon EKS (via service account token)"
        },
        "key_id": {
          "type": "string",
          "description": "KeyID is the AWS KMS key identifier (ARN or alias) used for signing operations.\nRequired when Type is 'aws_kms'."
        },
        "region": {
          "type": "string",
          "description": "Region is the AWS region where the KMS key is located.\nRequired when Type is 'aws_kms'."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "LoggerConfig": {
      "properties": {
        "log_health_and_metrics": {
          "type": "boolean",
          "description": "`log_health_and_metrics` determines whether requests of the `/health` and `/metrics` endpoints are logged.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "log_health_and_metrics"
      ]
    },
    "MFA": {
      "properties": {
        "acquire_on_login": {
          "type": "boolean",
          "description": "`acquire_on_login` configures if users are prompted creating an MFA credential on login.",
          "default": false
        },
        "acquire_on_registration": {
          "type": "boolean",
          "description": "`acquire_on_registration` configures if users are prompted creating an MFA credential on registration.",
          "default": true
        },
        "device_trust_cookie_name": {
          "type": "string",
          "description": "`device_trust_cookie_name` is the name of the cookie used to store the token of a trusted device.",
          "default": "hanko_device_token"
        },
        "device_trust_duration": {
          "type": "string",
          "description": "`device_trust_duration` configures the duration a device remains trusted after authentication; once expired, the\nuser must reauthenticate with MFA.",
          "default": "720h"
        },
        "device_trust_max_users_per_device": {
          "type": "integer",
          "description": "`device_trust_max_users_per_device` limits how many users can have device trust on a single device/browser.\nOldest entries are removed when the limit is exceeded. This allows multiple users to trust the same device\nwithout overwriting each other's trust tokens.",
          "default": 20
        },
        "device_trust_policy": {
          "type": "string",
          "enum": [
            "always",
            "prompt",
            "never"
          ],
          "description": "`device_trust_policy` determines the conditions under which a device or browser is considered trusted, allowing\nMFA to be skipped for subsequent logins.",
          "default": "prompt",
          "meta:enum": {
            "always": "Devices are trusted without user consent until the trust expires, so MFA is skipped during subsequent logins.",
            "never": "Devices are considered untrusted, so MFA is required for each login.",
            "prompt": "The user can choose to trust the current device to skip MFA for subsequent logins."
          }
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether multi-factor-authentication is enabled.",
          "default": true
        },
        "optional": {
          "type": "boolean",
          "description": "`optional` determines whether users must create an MFA credential when prompted. The MFA credential cannot be\ndeleted if multi-factor-authentication is required (`optional: false`).",
          "default": true
        },
        "security_keys": {
          "$ref": "#/$defs/SecurityKeys",
          "title": "security_keys",
          "description": "`security_keys` configures security key settings for multi-factor-authentication"
        },
        "totp": {
          "$ref": "#/$defs/TOTP",
          "title": "totp",
          "description": "`totp` configures the TOTP (Time-Based One-Time-Password) method for multi-factor-authentication."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "acquire_on_login",
        "acquire_on_registration",
        "device_trust_duration",
        "enabled",
        "optional"
      ]
    },
    "MultiTenant": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled enables multi-tenant mode. When disabled (default), Hanko operates in single-tenant mode\nwith global email/username uniqueness.",
          "default": false
        },
        "tenant_header": {
          "type": "string",
          "description": "TenantHeader is the HTTP header name used to identify the tenant.\nThe value must be a valid UUID.",
          "default": "X-Tenant-ID"
        },
        "allow_global_users": {
          "type": "boolean",
          "description": "AllowGlobalUsers allows users without a tenant_id (backward compatibility).\nWhen true, requests without the tenant header will create/access global users.\nWhen false, the tenant header is required for all requests.",
          "default": true
        },
        "auto_provision": {
          "type": "boolean",
          "description": "AutoProvision enables automatic tenant creation when a request includes a tenant ID\nthat doesn't exist yet. The tenant is created with default values.\nWhen false, requests with unknown tenant IDs will return a 404 error.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "MultiTenant configures multi-tenant mode for Hanko"
    },
    "Options": {
      "properties": {
        "sign_authn_requests": {
          "type": "boolean",
          "description": "`sign_authn_requests` determines whether initial requests should be signed.",
          "default": true
        },
        "force_login": {
          "type": "boolean",
          "description": "`force_login` forces the IdP to always show a login (even if there is an active session with the IdP).",
          "default": false
        },
        "validate_encryption_cert": {
          "type": "boolean",
          "description": "`validate_encryption_cert` determines whether the certificate used for the encryption of the IdP responses should\nbe checked for validity.",
          "default": true
        },
        "skip_signature_validation": {
          "type": "boolean",
          "description": "`skip_signature_validation` determines whether the validity check of an IdP response's signature\nshould be skipped.",
          "default": false
        },
        "allow_missing_attributes": {
          "type": "boolean",
          "description": "`allow_missing_attributes` determines whether missing attributes are allowed (e.g. the IdP specifies a phone\nattribute in the metadata but does not send it with a SAML Assertion Response).",
          "default": false
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Passcode": {
      "properties": {
        "ttl": {
          "type": "integer",
          "description": "Deprecated. Use `email.passcode_ttl` instead.",
          "default": 300
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Passkey": {
      "properties": {
        "acquire_on_registration": {
          "type": "string",
          "enum": [
            "always",
            "conditional",
            "never"
          ],
          "description": "`acquire_on_registration` configures how users are prompted creating a passkey on registration.",
          "default": "always",
          "meta:enum": {
            "always": "Indicates that users are always prompted to create a passkey on registration.",
            "conditional": "Indicates that users are prompted to create a passkey on registration as long as the user does\n\t\t\t\t\t\tnot have a password.\n\n\t\t\t\t\t\tIf passwords are also conditionally acquired on registration, then users are given a choice as\n\t\t\t\t\t\tto what type of credential to create.",
            "never": "Indicates that users are never prompted to create a passkey on registration."
          }
        },
        "acquire_on_login": {
          "type": "string",
          "enum": [
            "always",
            "conditional",
            "never"
          ],
          "description": "`acquire_on_login` configures how users are prompted creating a passkey on login.",
          "default": "always",
          "meta:enum": {
            "always": "Indicates that users are always prompted to create a passkey on login\n\t\t\t\t\tprovided that they do not already have a passkey.",
            "conditional": "Indicates that users are prompted to create a passkey on login provided that\n\t\t\t\t\t\tthey do not already have a passkey and do not have a password.\n\n\t\t\t\t\t\tIf passkeys are also conditionally acquired on login then users are given a choice as to what\n\t\t\t\t\t\ttype of credential to register.",
            "never": "Indicates that users are never prompted to create a passkey on login."
          }
        },
        "attestation_preference": {
          "type": "string",
          "enum": [
            "direct",
            "indirect",
            "none"
          ],
          "description": "`attestation_preference` is used to specify the preference regarding attestation conveyance during\ncredential generation.",
          "default": "direct",
          "meta:enum": {
            "direct": "Indicates that the Relying Party wants to receive the attestation statement as generated by\n\t\t\t\t\tthe authenticator.",
            "indirect": "Indicates that the Relying Party prefers an attestation conveyance yielding verifiable\n\t\t\t\t\tattestation statements, but allows the client to decide how to obtain such attestation statements.",
            "none": "Indicates that the Relying Party is not interested in authenticator attestation."
          }
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether users can create or authenticate with passkeys.",
          "default": true
        },
        "limit": {
          "type": "integer",
          "description": "`limit` defines the maximum number of passkeys a user can have.",
          "default": 10
        },
        "optional": {
          "type": "boolean",
          "description": "`optional` determines whether users must create a passkey when prompted. The last remaining passkey cannot be\ndeleted if passkeys are required (`optional: false`).\n\nIt also takes part in determining the order of password and passkey acquisition\non login and registration (see also `acquire_on_login` and `acquire_on_registration`): if one credential type is\nrequired (`optional: false`) then that one takes precedence, i.e. is acquired first.",
          "default": true
        },
        "user_verification": {
          "type": "string",
          "enum": [
            "required",
            "preferred",
            "discouraged"
          ],
          "description": "`user_verification` specifies the requirements regarding local authorization with an authenticator through\n various authorization gesture modalities; for example, through a touch plus pin code,\n password entry, or biometric recognition.\n\nThe setting applies to both WebAuthn registration and authentication ceremonies.",
          "default": "preferred",
          "meta:enum": {
            "discouraged": "Indicates that no user verification should be performed.",
            "preferred": "Indicates that user verification is preferred but will not fail the operation if no\n\t\t\t\t\t\tuser verification was performed.",
            "required": "Indicates that user verification is always required."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Password": {
      "properties": {
        "acquire_on_registration": {
          "type": "string",
          "enum": [
            "always",
            "conditional",
            "never"
          ],
          "description": "`acquire_on_registration` configures how users are prompted creating a password on registration.",
          "default": "always",
          "meta:enum": {
            "always": "Indicates that users are always prompted to create a password on registration.",
            "conditional": "Indicates that users are prompted to create a password on registration as long as the user does\n\t\t\t\t\t\tnot have a passkey.\n\n\t\t\t\t\t\tIf passkeys are also conditionally acquired on registration, then users are given a choice as\n\t\t\t\t\t\tto what type of credential to register.",
            "never": "Indicates that users are never prompted to create a password on registration."
          }
        },
        "acquire_on_login": {
          "type": "string",
          "enum": [
            "always",
            "conditional",
            "never"
          ],
          "description": "`acquire_on_login` configures how users are prompted creating a password on login.",
          "default": "never",
          "meta:enum": {
            "always": "Indicates that users are always prompted to create a password on login\n\t\t\t\t\tprovided that they do not already have a password.",
            "conditional": "Indicates that users are prompted to create a password on login provided that\n\t\t\t\t\t\tthey do not already have a password and do not have a passkey.\n\n\t\t\t\t\t\tIf passkeys are also conditionally acquired on login then users are given a choice as to what\n\t\t\t\t\t\ttype of credential to register.",
            "never": "Indicates that users are never prompted to create a password on login."
          }
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether passwords are enabled or disabled.",
          "default": true
        },
        "min_length": {
          "type": "integer",
          "description": "`min_length` determines the minimum password length.",
          "default": 8
        },
        "min_password_length": {
          "type": "integer",
          "description": "Deprecated. Use `min_length` instead.",
          "default": 8
        },
        "optional": {
          "type": "boolean",
          "description": "`optional` determines whether users must set a password when prompted. The password cannot be deleted if\npasswords are required (`optional: false`).\n\nIt also takes part in determining the order of password and passkey acquisition\non login and registration (see also `acquire_on_login` and `acquire_on_registration`): if one credential type is\nrequired (`optional: false`) then that one takes precedence, i.e. is acquired first.",
          "default": false
        },
        "recovery": {
          "type": "boolean",
          "description": "`recovery` determines whether users can start a recovery process, e.g. in case of a forgotten password.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Privacy": {
      "properties": {
        "show_account_existence_hints": {
          "type": "boolean",
          "description": "`show_account_existence_hints` determines whether the user should get a user-friendly response rather than a privacy protecting one. E.g. on sign-up, when enabled the user will get \"user already exists\" response.\nIt only has an effect when emails are enabled.",
          "default": false
        },
        "only_show_actual_login_methods": {
          "type": "boolean",
          "description": "`only_show_actual_login_methods` determines whether the user will only be prompted with his configured login methods.\nIt only has an effect when emails are enabled, can be used for authentication and passwords are enabled.",
          "default": false
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "RateLimiter": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` controls whether rate limiting is enabled or disabled.",
          "default": true
        },
        "store": {
          "type": "string",
          "enum": [
            "in_memory",
            "redis"
          ],
          "description": "`store` sets the store for the rate limiter. When you have multiple instances of Hanko running, it is recommended to use\n the `redis` store because otherwise your instances each have their own states.",
          "default": "in_memory"
        },
        "redis_config": {
          "$ref": "#/$defs/RedisConfig",
          "description": "`redis_config` configures connection to a redis instance.\nRequired if `store` is set to `redis`"
        },
        "passcode_limits": {
          "$ref": "#/$defs/RateLimits",
          "description": "`passcode_limits` controls rate limits for passcode operations."
        },
        "otp_limits": {
          "$ref": "#/$defs/RateLimits",
          "description": "`otp_limits` controls rate limits for OTP login attempts."
        },
        "password_limits": {
          "$ref": "#/$defs/RateLimits",
          "description": "`password_limits` controls rate limits for password login operations."
        },
        "token_limits": {
          "$ref": "#/$defs/RateLimits",
          "description": "`token_limits` controls rate limits for token exchange operations."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "RateLimits": {
      "properties": {
        "tokens": {
          "type": "integer",
          "description": "`tokens` determines how many operations/requests can occur in the given `interval`.",
          "default": 3
        },
        "interval": {
          "type": "string",
          "description": "`interval` determines when to reset the token interval.\nIt must be a (possibly signed) sequence of decimal\nnumbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"Âµs\"), \"ms\", \"s\", \"m\", \"h\".",
          "default": "1m"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "tokens",
        "interval"
      ]
    },
    "RedisConfig": {
      "properties": {
        "address": {
          "type": "string",
          "description": "`address` is the address of the redis instance in the form of `host[:port][/database]`."
        },
        "password": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "description": "`password` is the password for the redis instance."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "address"
      ]
    },
    "RelyingParty": {
      "properties": {
        "display_name": {
          "type": "string",
          "description": "`display_name` is the service's name that some WebAuthn Authenticators will display to the user during registration\nand authentication ceremonies.",
          "default": "Hanko Authentication Service"
        },
        "id": {
          "type": "string",
          "description": "`id` is the [effective domain](https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-effective-domain)\nthe passkey/WebAuthn credentials will be bound to.",
          "default": "localhost"
        },
        "origins": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "minItems": 1,
          "description": "`origins` is a list of origins for which passkeys/WebAuthn credentials will be accepted by the server. Must\ninclude the protocol and can only be the effective domain, or a registrable domain suffix of the effective\ndomain, as specified in the [`id`](#id). Except for `localhost`, the protocol **must** always be `https` for\npasskeys/WebAuthn to work. IP Addresses will not work.\n\nFor an Android application the origin must be the base64 url encoded SHA256 fingerprint of the signing\ncertificate.",
          "default": [
            "http://localhost:8888"
          ]
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "RelyingParty webauthn settings for your application using hanko."
    },
    "SMTP": {
      "properties": {
        "host": {
          "type": "string",
          "default": "localhost"
        },
        "port": {
          "type": "string",
          "default": "465"
        },
        "user": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "SMTP Server Settings for sending passcodes"
    },
    "Saml": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether the SAML API endpoints are available.",
          "default": false
        },
        "endpoint_url": {
          "type": "string",
          "description": "`endpoint` is URL at which the SAML endpoints like metadata, callback, etc. are available\n(e.g. `{YOUR_BACKEND_INSTANCE}/api`).\n\nWill be provided as metadata for IdP."
        },
        "audience_uri": {
          "type": "string",
          "description": "`audience_uri` determines the intended recipient or audience for the SAML Assertion."
        },
        "default_redirect_url": {
          "type": "string",
          "description": "`default_redirect_url` is the URL to redirect to in case of errors or when no `allowed_redirect_url` is provided."
        },
        "allowed_redirect_urls": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "`allowed_redirect_urls` is a list of URLs the backend is allowed to redirect to after third party sign-in was\nsuccessful.\n\nSupports wildcard matching through globbing. e.g. `https://*.example.com` will allow `https://foo.example.com`\nand `https://bar.example.com` to be accepted.\n\nGlobbing is also supported for paths, e.g. `https://foo.example.com/*` will match `https://foo.example.com/page1`\nand `https://foo.example.com/page2`.\n\nA double asterisk (`**`) acts as a \"super\"-wildcard/match-all.\n\nSee [here](https://pkg.go.dev/github.com/gobwas/glob#Compile) for more on globbinh."
        },
        "options": {
          "$ref": "#/$defs/Options",
          "title": "options",
          "description": "`options` allows setting optional features for service provider operations."
        },
        "identity_providers": {
          "items": {
            "$ref": "#/$defs/IdentityProvider"
          },
          "type": "array",
          "description": "`identity_providers` is a list of SAML identity providers."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Secrets": {
      "if": {
        "properties": {
          "key_management": {
            "properties": {
              "type": {
                "const": "local"
              }
            }
          }
        }
      },
      "then": {
        "properties": {
          "keys": {
            "minItems": 1
          }
        }
      },
      "properties": {
        "key_management": {
          "$ref": "#/$defs/KeyManagement",
          "description": "KeyManagement configures the key management system used for signing JWTs.\nSupports 'local' (default) which uses the keys defined in the 'keys' field to encrypt a newly generated private\nRSA key in the database, or 'aws_kms' which uses AWS Key Management Service for key signatures."
        },
        "keys": {
          "items": {
            "type": "string",
            "minLength": 16,
            "title": "keys"
          },
          "type": "array",
          "description": "`keys` are used to en- and decrypt the JWKs which get used to sign the JWTs issued by the API.\nFor every key a JWK is generated, encrypted with the key and persisted in the database.\n\nYou can use this list for key rotation: add a new key to the beginning of the list and the corresponding\nJWK will then be used for signing JWTs. All tokens signed with the previous JWK(s) will still\nbe valid until they expire. Removing a key from the list does not remove the corresponding\ndatabase record. If you remove a key, you also have to remove the database record, otherwise\napplication startup will fail."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SecurityKeys": {
      "properties": {
        "attestation_preference": {
          "type": "string",
          "enum": [
            "direct",
            "indirect",
            "none"
          ],
          "description": "`attestation_preference` is used to specify the preference regarding attestation conveyance during\ncredential generation.",
          "default": "direct"
        },
        "authenticator_attachment": {
          "type": "string",
          "enum": [
            "platform",
            "cross-platform",
            "no_preference"
          ],
          "description": "`authenticator_attachment`  is used to specify the preference regarding authenticator attachment during credential registration.",
          "default": "cross-platform"
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether security keys are eligible for multi-factor-authentication.",
          "default": true
        },
        "limit": {
          "type": "integer",
          "description": "'limit' determines the maximum number of security keys a user can register.",
          "default": 10
        },
        "user_verification": {
          "type": "string",
          "enum": [
            "required",
            "preferred",
            "discouraged"
          ],
          "description": "`user_verification` specifies the requirements regarding local authorization with an authenticator through\n various authorization gesture modalities; for example, through a touch plus pin code,\n password entry, or biometric recognition.\n\nThe setting applies to both WebAuthn registration and authentication ceremonies.",
          "default": "discouraged"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "enabled"
      ]
    },
    "SecurityNotificationConfiguration": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SecurityNotificationTypes": {
      "properties": {
        "password_update": {
          "$ref": "#/$defs/SecurityNotificationConfiguration"
        },
        "primary_email_update": {
          "$ref": "#/$defs/SecurityNotificationConfiguration"
        },
        "email_create": {
          "$ref": "#/$defs/SecurityNotificationConfiguration"
        },
        "email_delete": {
          "$ref": "#/$defs/SecurityNotificationConfiguration"
        },
        "passkey_create": {
          "$ref": "#/$defs/SecurityNotificationConfiguration"
        },
        "mfa_create": {
          "$ref": "#/$defs/SecurityNotificationConfiguration"
        },
        "mfa_delete": {
          "$ref": "#/$defs/SecurityNotificationConfiguration"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SecurityNotifications": {
      "properties": {
        "notifications": {
          "$ref": "#/$defs/SecurityNotificationTypes"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Server": {
      "properties": {
        "public": {
          "$ref": "#/$defs/ServerSettings",
          "title": "public",
          "description": "`public` contains the server configuration for the public API."
        },
        "admin": {
          "$ref": "#/$defs/ServerSettings",
          "title": "admin",
          "description": "`admin` contains the server configuration for the admin API."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ServerSettings": {
      "properties": {
        "address": {
          "type": "string",
          "description": "`address` is the address of the server to listen on in the form of host:port.\n\nSee [net.Dial](https://pkg.go.dev/net#Dial) for details of the address format."
        },
        "cors": {
          "$ref": "#/$defs/Cors",
          "title": "cors",
          "description": "`cors` contains configuration options regarding Cross-Origin-Resource-Sharing."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ServerSide": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether server-side sessions are enabled.\n\nNOTE: When enabled the session endpoint must be used in order to check if a session is still valid.",
          "default": false
        },
        "limit": {
          "type": "integer",
          "description": "`limit` determines the maximum number of server-side sessions a user can have. When the limit is exceeded,\nolder sessions are invalidated.",
          "default": 100
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Service": {
      "properties": {
        "name": {
          "type": "string",
          "description": "`name` determines the name of the service.\nThis value is used, e.g. in the subject header of outgoing emails."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Session": {
      "properties": {
        "allow_revocation": {
          "type": "boolean",
          "description": "`allow_revocation` allows users to revoke their own sessions.",
          "default": true
        },
        "audience": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "`audience` is a list of strings that identifies the recipients that the JWT is intended for.\nThe audiences are placed in the `aud` claim of the JWT.\nIf not set, it defaults to the value of the`webauthn.relying_party.id` configuration parameter."
        },
        "acquire_ip_address": {
          "type": "boolean",
          "description": "`acquire_ip_address` stores the user's IP address in the database.",
          "default": true
        },
        "acquire_user_agent": {
          "type": "boolean",
          "description": "`acquire_user_agent` stores the user's user agent in the database.",
          "default": true
        },
        "cookie": {
          "$ref": "#/$defs/Cookie",
          "description": "`cookie` contains configuration for the session cookie issued on successful registration or login."
        },
        "enable_auth_token_header": {
          "type": "boolean",
          "description": "`enable_auth_token_header` determines whether a session token (JWT) is returned in an `X-Auth-Token`\nheader after a successful authentication. This option should be set to `true` if API and client applications\nrun on different domains.",
          "default": false
        },
        "issuer": {
          "type": "string",
          "description": "`issuer` is a string that identifies the principal (human user, an organization, or a service)\nthat issued the JWT. Its value is set in the `iss` claim of a JWT."
        },
        "lifespan": {
          "type": "string",
          "description": "`lifespan` determines the maximum duration for which a session token (JWT) is valid. It must be a (possibly signed) sequence of decimal\nnumbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"Âµs\"), \"ms\", \"s\", \"m\", \"h\".",
          "default": "12h"
        },
        "limit": {
          "type": "integer",
          "description": "`limit` determines the maximum number of server-side sessions a user can have. When the limit is exceeded,\nolder sessions are invalidated.",
          "default": 5
        },
        "show_on_profile": {
          "type": "boolean",
          "description": "`show_on_profile` indicates that the sessions should be listed on the profile.",
          "default": true
        },
        "server_side": {
          "$ref": "#/$defs/ServerSide",
          "description": "Deprecated. Use settings in parent object.\n`server_side` contains configuration for server-side sessions."
        },
        "jwt_template": {
          "$ref": "#/$defs/JWTTemplate",
          "description": "`jwt_template` defines a template for adding custom `claims` to session JWTs.\n\nThese claims are processed at JWT generation time and can include static values,\ntemplated strings using Go's text/template syntax, or nested structures (maps and slices).\n\nThe template has access to user data via the `.User` field, which includes:\n- `.User.UserID`: The user's unique ID (string)\n- `.User.Email`: Email details (optional, with `.Address`, `.IsPrimary`, `.IsVerified`)\n- `.User.Username`: The user's username (string, optional)\n\nClaims that fail to process (e.g., due to invalid templates) are logged and skipped,\nensuring JWT generation continues without interruption.\n\nExample usage in YAML configuration:\n```yaml\nsession:\n  lifespan: 24h\n  jwt_template:\n    claims:\n      role: \"user\"                               # Static value\n      user_email: \"{{.User.Email.Address}}\"      # Templated string\n      is_verified: \"{{.User.Email.IsVerified}}\"  # Boolean from user data\n      metadata:                                  # Nested map\n        source: \"hanko\"\n        greeting: \"Hello {{.User.Username}}\"\n      scopes:                                    # Slice with templated value\n        - \"read\"\n        - \"write\"\n        - \"{{if .User.Email.IsVerified}}admin{{else}}basic{{end}}\"\n```\n\nIn this example:\n- `role` is a static string (\"user\").\n- `user_email` dynamically inserts the user's email address.\n- `is_verified` inserts a boolean indicating email verification status.\n- `metadata` is a nested map with a static `source` and a templated `greeting`.\n- `scopes` is a slice combining static values and a conditional template.\n\nNotes:\n- Claims with the following keys will be ignored because they are currently added to the JWT\n  by default:\n    - sub\n    - iat\n    - exp\n    - aud\n    - iss\n    - email\n    - username\n    - session_id\n- Templates must be valid Go `text/template` syntax. Invalid templates are logged and ignored.\n- Boolean strings (\"true\" or \"false\") from templates are automatically converted to actual booleans.\n- Use conditionals (e.g., `{{if .User.Email}}`) to handle optional fields safely.\n\nFor more details on template syntax, see: https://pkg.go.dev/text/template"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "TOTP": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether TOTP is eligible for multi-factor-authentication.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "enabled"
      ]
    },
    "ThirdParty": {
      "if": {
        "allOf": [
          {
            "properties": {
              "providers": {
                "patternProperties": {
                  "^.*": {
                    "$ref": "#/$defs/ThirdPartyProvider",
                    "properties": {
                      "enabled": {
                        "anyOf": [
                          {
                            "const": false
                          },
                          {
                            "const": "null"
                          }
                        ]
                      }
                    }
                  }
                },
                "type": "object"
              }
            }
          },
          {
            "properties": {
              "custom_providers": {
                "additionalProperties": {
                  "$ref": "#/$defs/CustomThirdPartyProvider",
                  "properties": {
                    "enabled": {
                      "anyOf": [
                        {
                          "const": false
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        ]
      },
      "then": {},
      "else": {
        "required": [
          "redirect_url",
          "error_redirect_url",
          "allowed_redirect_urls"
        ]
      },
      "properties": {
        "providers": {
          "$ref": "#/$defs/ThirdPartyProviders",
          "title": "providers",
          "description": "`providers` contains the configurations for the available OAuth/OIDC identity providers."
        },
        "custom_providers": {
          "$ref": "#/$defs/CustomThirdPartyProviders",
          "title": "custom_providers",
          "description": "`custom_providers contains the configurations for custom OAuth/OIDC identity providers."
        },
        "redirect_url": {
          "type": "string",
          "description": "`redirect_url` is the URL the third party provider redirects to with an authorization code. Must consist of the base URL\nof your running Hanko backend instance and the `callback` endpoint of the API,\ni.e. `{YOUR_BACKEND_INSTANCE}/thirdparty/callback.`\n\nRequired if any of the [`providers`](#providers) are `enabled`.",
          "examples": [
            "https://yourinstance.com/thirdparty/callback"
          ]
        },
        "error_redirect_url": {
          "type": "string",
          "description": "`error_redirect_url` is the URL the backend redirects to if an error occurs during third party sign-in.\nErrors are provided as 'error' and 'error_description' query params in the redirect location URL.\n\nWhen using the Hanko web components it should be the URL of the page that embeds the web component such that\nerrors can be processed properly by the web component.\n\nYou do not have to add this URL to the 'allowed_redirect_urls', it is automatically included when validating\nredirect URLs.\n\nRequired if any of the [`providers`](#providers) are `enabled`. Must not have trailing slash."
        },
        "default_redirect_url": {
          "type": "string",
          "description": "`default_redirect_url` is the URL the backend redirects to after it successfully verified\nthe response from any third party provider.\n\nMust not have trailing slash."
        },
        "allowed_redirect_urls": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "minItems": 1,
          "description": "`allowed_redirect_urls` is a list of URLs the backend is allowed to redirect to after third party sign-in was\nsuccessful.\n\nSupports wildcard matching through globbing. e.g. `https://*.example.com` will allow `https://foo.example.com`\nand `https://bar.example.com` to be accepted.\n\nGlobbing is also supported for paths, e.g. `https://foo.example.com/*` will match `https://foo.example.com/page1`\nand `https://foo.example.com/page2`.\n\nA double asterisk (`**`) acts as a \"super\"-wildcard/match-all.\n\nSee [here](https://pkg.go.dev/github.com/gobwas/glob#Compile) for more on globbing.\n\nMust not be empty if any of the [`providers`](#providers) are `enabled`. URLs in the list must not have a trailing slash."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ThirdPartyProvider": {
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "client_id",
          "secret"
        ]
      },
      "else": {},
      "properties": {
        "allow_linking": {
          "type": "boolean",
          "description": "`allow_linking` indicates whether existing accounts can be automatically linked with this provider.\n\nLinking is based on matching one of the email addresses of an existing user account with the (primary)\nemail address of the third party provider account."
        },
        "client_id": {
          "type": "string",
          "description": "`client_id` is the ID of the OAuth/OIDC client. Must be obtained from the provider.\n\nRequired if the provider is `enabled`."
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether this provider is enabled.",
          "default": false
        },
        "prompt": {
          "type": "string",
          "description": "`prompt` specifies whether the Authorization Server prompts the End-User for reauthentication and consent.\nPossible values are:\n- login\n- none\n- consent\n- select_account\nPlease note that not all providers support all values. Check the corresponding docs of the provider for supported values."
        },
        "secret": {
          "type": "string",
          "description": "`secret` is the client secret for the OAuth/OIDC client. Must be obtained from the provider.\n\nRequired if the provider is `enabled`."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "provider"
    },
    "ThirdPartyProviders": {
      "properties": {
        "apple": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`apple` contains the provider configuration for Apple."
        },
        "discord": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`discord` contains the provider configuration for Discord."
        },
        "github": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`github` contains the provider configuration for GitHub."
        },
        "google": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`google` contains the provider configuration for Google."
        },
        "linkedin": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`linkedin` contains the provider configuration for LinkedIn."
        },
        "microsoft": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`microsoft` contains the provider configuration for Microsoft."
        },
        "facebook": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`facebook` contains the provider configuration for Facebook."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Username": {
      "properties": {
        "acquire_on_login": {
          "type": "boolean",
          "description": "`acquire_on_login` determines whether users, provided that they do not already have set a username,\n\tare prompted to provide a username on login.",
          "default": true
        },
        "acquire_on_registration": {
          "type": "boolean",
          "description": "`acquire_on_registration` determines whether users are prompted to provide a username on registration.",
          "default": true
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether users can set a unique username.\n\nUsernames can contain letters (a-z,A-Z), numbers (0-9), and underscores.",
          "default": false
        },
        "max_length": {
          "type": "integer",
          "description": "`max_length` specifies the maximum allowed length of a username.",
          "default": 32
        },
        "min_length": {
          "type": "integer",
          "description": "`min_length` specifies the minimum length of a username.",
          "default": 3
        },
        "optional": {
          "type": "boolean",
          "description": "`optional` determines whether users must provide a username when prompted. The username can only be changed but\nnot deleted if usernames are required (`optional: false`).",
          "default": true
        },
        "use_as_login_identifier": {
          "type": "boolean",
          "description": "`use_as_login_identifier` determines whether usernames, if enabled, can be used for logging in.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "WebauthnSettings": {
      "properties": {
        "relying_party": {
          "$ref": "#/$defs/RelyingParty",
          "title": "relying_party"
        },
        "timeout": {
          "type": "integer",
          "description": "Deprecated, use `timeouts` instead.",
          "default": 60000
        },
        "timeouts": {
          "$ref": "#/$defs/WebauthnTimeouts",
          "title": "timeouts",
          "description": "`timeouts` specifies the timeouts for passkey/WebAuthn registration and login."
        },
        "user_verification": {
          "type": "string",
          "enum": [
            "required",
            "preferred",
            "discouraged"
          ],
          "description": "Deprecated, use `passkey.user_verification` instead",
          "default": "preferred"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "WebauthnSettings defines the settings for the webauthn authentication mechanism"
    },
    "WebauthnTimeouts": {
      "properties": {
        "registration": {
          "type": "integer",
          "description": "`registration` determines the time, in milliseconds, that the client is willing to wait for the credential\ncreation request to the WebAuthn API to complete.",
          "default": 600000
        },
        "login": {
          "type": "integer",
          "description": "`login` determines the time, in milliseconds, that the client is willing to wait for the credential\n request to the WebAuthn API to complete.",
          "default": 600000
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Webhook": {
      "properties": {
        "callback": {
          "type": "string",
          "description": "`callback` specifies the URL to which the change data will be sent."
        },
        "events": {
          "$ref": "#/$defs/Events",
          "items": {
            "type": "string",
            "enum": [
              "user",
              "user.create",
              "user.delete",
              "user.login",
              "user.update",
              "user.update.email",
              "user.update.email.create",
              "user.update.email.delete",
              "user.update.email.primary",
              "user.update.password.update",
              "user.update.username",
              "user.update.username.create",
              "user.update.username.delete",
              "user.update.username.update",
              "email.send"
            ],
            "title": "events",
            "meta:enum": {
              "email.send": "Triggers on: an email was sent or should be sent",
              "user": "Triggers on: user creation, user deletion, user update, email creation, email deletion, change of primary email",
              "user.create": "Triggers on: user creation",
              "user.delete": "Triggers on: user deletion",
              "user.login": "Triggers on: user login",
              "user.update": "Triggers on: user update, email creation, email deletion, change of primary email",
              "user.update.email": "Triggers on: email creation, email deletion, change of primary email",
              "user.update.email.create": "Triggers on: email creation",
              "user.update.email.delete": "Triggers on: email deletion",
              "user.update.email.primary": "Triggers on: change of primary email",
              "user.update.password.update": "Triggers on: change of password",
              "user.update.username": "Triggers on: username creation, username deletion, change of username",
              "user.update.username.create": "Triggers on: username creation",
              "user.update.username.delete": "Triggers on: username deletion",
              "user.update.username.update": "Triggers on: change of username"
            }
          },
          "title": "events",
          "description": "`events` is a list of events this hook listens for."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "hooks"
    },
    "WebhookSettings": {
      "properties": {
        "allow_time_expiration": {
          "type": "boolean",
          "description": "`allow_time_expiration` determines whether webhooks are disabled when unused for 30 days\n(only for database webhooks).",
          "default": false
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` enables the webhook feature.",
          "default": false
        },
        "hooks": {
          "$ref": "#/$defs/Webhooks",
          "title": "hooks",
          "description": "`hooks` is a list of Webhook configurations.\n\nWhen using environment variables the value for the `WEBHOOKS_HOOKS` key must be specified in the following\nformat:\n`{\"callback\":\"http://app.com/usercb\",\"events\":[\"user\"]};{\"callback\":\"http://app.com/emailcb\",\"events\":[\"email.send\"]}`"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Webhooks": {
      "items": {
        "$ref": "#/$defs/Webhook"
      },
      "type": "array"
    }
  },
  "title": "Config"
}
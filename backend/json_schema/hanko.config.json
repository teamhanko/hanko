{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://github.com/teamhanko/hanko/backend/config/config",
  "$ref": "#/$defs/Config",
  "$defs": {
    "Account": {
      "properties": {
        "allow_deletion": {
          "type": "boolean",
          "description": "`allow_deletion` determines whether users can delete their accounts.",
          "default": false
        },
        "allow_signup": {
          "type": "boolean",
          "description": "`allow_signup` determines whether users are able to create new accounts.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "AttributeMap": {
      "properties": {
        "name": {
          "type": "string",
          "default": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name"
        },
        "family_name": {
          "type": "string",
          "default": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname"
        },
        "given_name": {
          "type": "string",
          "default": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname"
        },
        "middle_name": {
          "type": "string"
        },
        "nickname": {
          "type": "string"
        },
        "preferred_username": {
          "type": "string"
        },
        "profile": {
          "type": "string"
        },
        "picture": {
          "type": "string"
        },
        "website": {
          "type": "string"
        },
        "gender": {
          "type": "string"
        },
        "birthdate": {
          "type": "string"
        },
        "zone_info": {
          "type": "string"
        },
        "locale": {
          "type": "string"
        },
        "updated_at": {
          "type": "string"
        },
        "email": {
          "type": "string",
          "default": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress"
        },
        "email_verified": {
          "type": "string"
        },
        "phone": {
          "type": "string"
        },
        "phone_verified": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "AuditLog": {
      "properties": {
        "console_output": {
          "$ref": "#/$defs/AuditLogConsole",
          "title": "console_output",
          "description": "`console_output` controls audit log console output."
        },
        "mask": {
          "type": "boolean",
          "description": "`mask` determines whether sensitive information (usernames, emails) should be masked in the audit log output.\n\nThis configuration applies to logs written to the console as well as persisted logs.",
          "default": true
        },
        "storage": {
          "$ref": "#/$defs/AuditLogStorage",
          "description": "`storage` controls audit log retention."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "AuditLogConsole": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` controls whether audit log output on the console is enabled or disabled.",
          "default": true
        },
        "output": {
          "type": "string",
          "enum": [
            "stdout",
            "stderr"
          ],
          "description": "`output` determines the output stream audit logs are sent to.",
          "default": "stdout"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "AuditLogStorage": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` controls whether audit log should be retained (i.e. persisted).",
          "default": false
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Config": {
      "properties": {
        "account": {
          "$ref": "#/$defs/Account",
          "title": "account",
          "description": "`account` configures settings related to user accounts."
        },
        "audit_log": {
          "$ref": "#/$defs/AuditLog",
          "title": "audit_log",
          "description": "`audit_log` configures output and storage modalities of audit logs."
        },
        "convert_legacy_config": {
          "type": "boolean",
          "description": "`convert_legacy_config`, if set to `true`, automatically copies the set values of deprecated configuration\noptions, to new ones. If set to `false`, these values have to be set manually if non-default values should be\nused.",
          "default": false
        },
        "database": {
          "$ref": "#/$defs/Database",
          "title": "database",
          "description": "`database` configures database connection settings."
        },
        "debug": {
          "type": "boolean",
          "description": "`debug`, if set to `true`, adds additional debugging information to flow API responses.",
          "default": false
        },
        "email": {
          "$ref": "#/$defs/Email",
          "title": "email",
          "description": "`email` configures how email addresses of user accounts are acquired and used."
        },
        "email_delivery": {
          "$ref": "#/$defs/EmailDelivery",
          "title": "email_delivery",
          "description": "`email_delivery` configures how outgoing mails are delivered."
        },
        "emails": {
          "$ref": "#/$defs/Emails",
          "title": "emails",
          "description": "Deprecated. See child properties for suggested replacements."
        },
        "log": {
          "$ref": "#/$defs/LoggerConfig",
          "title": "log",
          "description": "`log` configures application logging."
        },
        "passcode": {
          "$ref": "#/$defs/Passcode",
          "title": "passcode",
          "description": "Deprecated. See child properties for suggested replacements."
        },
        "passkey": {
          "$ref": "#/$defs/Passkey",
          "title": "passkey",
          "description": "`passkey` configures how passkeys  are acquired and used."
        },
        "password": {
          "$ref": "#/$defs/Password",
          "title": "password",
          "description": "`password` configures how passwords are acquired and used."
        },
        "rate_limiter": {
          "$ref": "#/$defs/RateLimiter",
          "title": "rate_limiter",
          "description": "`rate_limiter` configures rate limits for rate limited API operations and storage modalities for rate limit data."
        },
        "saml": {
          "$ref": "#/$defs/Saml",
          "title": "saml",
          "description": "`saml` configures modalities of SAML (Security Assertion Markup Language) SSO authentication and SAML identity\nproviders."
        },
        "secrets": {
          "$ref": "#/$defs/Secrets",
          "title": "secrets",
          "description": "`secrets` configures the keys used for cryptographically signing tokens issued by the API."
        },
        "server": {
          "$ref": "#/$defs/Server",
          "title": "server",
          "description": "`server` configures address and CORS settings of the public and admin API."
        },
        "service": {
          "$ref": "#/$defs/Service",
          "title": "service",
          "description": "`service` configures general service information."
        },
        "session": {
          "$ref": "#/$defs/Session",
          "title": "session",
          "description": "`session` configures settings for session JWTs and Cookies issued by the API."
        },
        "smtp": {
          "$ref": "#/$defs/SMTP",
          "title": "smtp",
          "description": "Deprecated. Use `email_delivery.smtp` instead."
        },
        "third_party": {
          "$ref": "#/$defs/ThirdParty",
          "title": "third_party",
          "description": "`third_party` configures the modalities of third party OAuth/OIDC based authentication and available identity\nproviders."
        },
        "username": {
          "$ref": "#/$defs/Username",
          "title": "username",
          "description": "`username` configures how usernames of user accounts are acquired and used."
        },
        "webauthn": {
          "$ref": "#/$defs/WebauthnSettings",
          "title": "webauthn",
          "description": "`webauthn` configures general settings for communication with the WebAuthentication API."
        },
        "webhooks": {
          "$ref": "#/$defs/WebhookSettings",
          "title": "webhooks",
          "description": "`webhooks` configures HTTP-based callbacks for specific events occurring in the system."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "Config is the central configuration type"
    },
    "Cookie": {
      "properties": {
        "domain": {
          "type": "string",
          "description": "`domain` is the domain the cookie will be bound to. Works for subdomains, but not cross-domain.\nSee the `session.enable_auth_token_header` configuration instead if the API and the client application run on\ndifferent domains.",
          "default": "hanko"
        },
        "http_only": {
          "type": "boolean",
          "description": "`http_only` determines whether cookies are HTTP only or accessible by Javascript.",
          "default": true
        },
        "name": {
          "type": "string",
          "description": "`name` is the name of the cookie.",
          "default": "hanko"
        },
        "same_site": {
          "type": "string",
          "enum": [
            "strict",
            "lax",
            "none"
          ],
          "description": "`same_site` controls whether a cookie is sent with cross-site requests.\nSee [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value) for\nmore details.",
          "default": "strict"
        },
        "secure": {
          "type": "boolean",
          "description": "`secure` indicates whether the cookie is sent to the server only when a request is made with the https: scheme\n(except on localhost).\n\nNOTE: `secure` must be set to `false` when working on `localhost` and with the Safari browser because it does\nnot store secure cookies on `localhost`.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Cors": {
      "properties": {
        "allow_origins": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "allow_origins",
          "description": "`allow_origins` determines the value of the Access-Control-Allow-Origin\nresponse header. This header defines a list of [origins](https://developer.mozilla.org/en-US/docs/Glossary/Origin)\nthat may access the resource.\n\nThe wildcard characters `*` and `?` are supported and are converted to regex fragments `.*` and `.` accordingly.",
          "default": [
            "http://localhost:8888"
          ]
        },
        "unsafe_wildcard_origin_allowed": {
          "type": "boolean",
          "title": "unsafe_wildcard_origin_allowed",
          "description": "`unsafe_wildcard_origin_allowed` allows a wildcard `*` origin to be used with AllowCredentials\nflag. In that case we consider any origin allowed and send it back to the client in an `Access-Control-Allow-Origin` header.\n\nThis is INSECURE and potentially leads to [cross-origin](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\nattacks. See also https://github.com/labstack/echo/issues/2400 for discussion on the subject.\n\nOptional. Default value is `false`.",
          "default": false
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Database": {
      "properties": {
        "database": {
          "type": "string",
          "description": "`database` determines the name of the database schema to use.",
          "default": "hanko"
        },
        "dialect": {
          "type": "string",
          "enum": [
            "postgres",
            "mysql",
            "mariadb",
            "cockroach"
          ],
          "description": "`dialect` is the name of the database system to use.",
          "default": "postgres"
        },
        "host": {
          "type": "string",
          "description": "`host` is the host the database system is running on.",
          "default": "localhost"
        },
        "password": {
          "type": "string",
          "description": "`password` is the password for the database user to use for connecting to the database.",
          "default": "hanko"
        },
        "port": {
          "type": "string",
          "description": "`port` is the port the database system is running on.",
          "default": "5432"
        },
        "url": {
          "type": "string",
          "description": "`url` is a datasource connection string. It can be used instead of the rest of the database configuration\noptions. If this `url` is set then it is prioritized, i.e. the rest of the options, if set, have no effect.\n\nSchema: `dialect://username:password@host:port/database`",
          "examples": [
            "postgres://hanko:hanko@localhost:5432/hanko"
          ]
        },
        "user": {
          "type": "string",
          "description": "`user` is the database user to use for connecting to the database.",
          "default": "hanko"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Email": {
      "properties": {
        "acquire_on_login": {
          "type": "boolean",
          "description": "`acquire_on_login` determines whether users, provided that they do not already have registered an email,\n\tare prompted to provide an email on login.",
          "default": false
        },
        "acquire_on_registration": {
          "type": "boolean",
          "description": "`acquire_on_registration` determines whether users are prompted to provide an email on registration.",
          "default": true
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether emails are enabled.",
          "default": true
        },
        "limit": {
          "type": "integer",
          "description": "'limit' determines the maximum number of emails a user can register.",
          "default": 5
        },
        "max_length": {
          "type": "integer",
          "description": "`max_length` specifies the maximum allowed length of an email address.",
          "default": 100
        },
        "optional": {
          "type": "boolean",
          "description": "`optional` determines whether users must provide an email when prompted.\nThere must always be at least one email address associated with an account. The primary email address cannot be\ndeleted if emails are required (`optional`: false`).",
          "default": false
        },
        "passcode_ttl": {
          "type": "integer",
          "description": "`passcode_ttl` specifies, in seconds, how long a passcode is valid for.",
          "default": 300
        },
        "require_verification": {
          "type": "boolean",
          "description": "`require_verification` determines whether newly created emails must be verified by providing a passcode sent\nto respective address.",
          "default": true
        },
        "use_as_login_identifier": {
          "type": "boolean",
          "description": "`use_as_login_identifier` determines whether emails can be used as an identifier on login.",
          "default": true
        },
        "use_for_authentication": {
          "type": "boolean",
          "description": "`user_for_authentication` determines whether users can log in by providing an email address and subsequently\nproviding a passcode sent to the given email address.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "EmailDelivery": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether the API delivers emails.\nDisable if you want to send the emails yourself. To do so you must subscribe to the `email.create` webhook event.",
          "default": true
        },
        "from_address": {
          "type": "string",
          "description": "`from_address` configures the sender address of emails sent to users.",
          "default": "noreply@hanko.io"
        },
        "from_name": {
          "type": "string",
          "description": "`from_name` configures the sender name of emails sent to users.",
          "default": "Hanko"
        },
        "smtp": {
          "$ref": "#/$defs/SMTP",
          "title": "smtp",
          "description": "`SMTP` contains the SMTP server settings for sending mails."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Emails": {
      "properties": {
        "require_verification": {
          "type": "boolean",
          "description": "Deprecated. Use `email.require_verification` instead.",
          "default": true
        },
        "max_num_of_addresses": {
          "type": "integer",
          "description": "Deprecated. Use `email.limit` instead.",
          "default": 5
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Events": {
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "IdentityProvider": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` activates or deactivates the identity provider.",
          "default": false
        },
        "name": {
          "type": "string",
          "description": "`name` is the name given for the identity provider."
        },
        "domain": {
          "type": "string",
          "description": "At login the domain will be extracted from the users email address and then used to identify the idp to use.\nThis tag defines for which domain the idp is used."
        },
        "metadata_url": {
          "type": "string",
          "description": "`metadata_url` is the URL the API can retrieve IdP metadata from."
        },
        "skip_email_verification": {
          "type": "boolean",
          "description": "`skip_email_verification` determines whether the check if the `email_verified` attribute in the IdP response\nwill be skipped."
        },
        "attribute_map": {
          "$ref": "#/$defs/AttributeMap",
          "title": "attribute_map",
          "description": "`attribute_map` is a map of attributes used to map attributes in IdP response to custom attributes at\nHanko."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "LoggerConfig": {
      "properties": {
        "log_health_and_metrics": {
          "type": "boolean",
          "description": "`log_health_and_metrics` determines whether requests of the `/health` and `/metrics` endpoints are logged.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "log_health_and_metrics"
      ]
    },
    "Options": {
      "properties": {
        "sign_authn_requests": {
          "type": "boolean",
          "description": "`sign_authn_requests` determines whether initial requests should be signed.",
          "default": true
        },
        "force_login": {
          "type": "boolean",
          "description": "`force_login` forces the IdP to always show a login (even if there is an active session with the IdP).",
          "default": false
        },
        "validate_encryption_cert": {
          "type": "boolean",
          "description": "`validate_encryption_cert` determines whether the certificate used for the encryption of the IdP responses should\nbe checked for validity.",
          "default": true
        },
        "skip_signature_validation": {
          "type": "boolean",
          "description": "`skip_signature_validation` determines whether the validity check of an IdP response's signature\nshould be skipped.",
          "default": false
        },
        "allow_missing_attributes": {
          "type": "boolean",
          "description": "`allow_missing_attributes` determines whether missing attributes are allowed (e.g. the IdP specifies a phone\nattribute in the metadata but does not send it with a SAML Assertion Response).",
          "default": false
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Passcode": {
      "properties": {
        "ttl": {
          "type": "integer",
          "description": "Deprecated. Use `email.passcode_ttl` instead.",
          "default": 300
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Passkey": {
      "properties": {
        "acquire_on_registration": {
          "type": "string",
          "enum": [
            "always",
            "conditional",
            "never"
          ],
          "description": "`acquire_on_registration` configures how users are prompted creating a passkey on registration.",
          "default": "always",
          "meta:enum": {
            "always": "Indicates that users are always prompted to create a passkey on registration.",
            "conditional": "Indicates that users are prompted to create a passkey on registration as long as the user does\n\t\t\t\t\t\tnot have a password.\n\n\t\t\t\t\t\tIf passwords are also conditionally acquired on registration, then users are given a choice as\n\t\t\t\t\t\tto what type of credential to create.",
            "never": "Indicates that users are never prompted to create a passkey on registration."
          }
        },
        "acquire_on_login": {
          "type": "string",
          "enum": [
            "always",
            "conditional",
            "never"
          ],
          "description": "`acquire_on_login` configures how users are prompted creating a passkey on login.",
          "default": "always",
          "meta:enum": {
            "always": "Indicates that users are always prompted to create a passkey on login\n\t\t\t\t\tprovided that they do not already have a passkey.",
            "conditional": "Indicates that users are prompted to create a passkey on login provided that\n\t\t\t\t\t\tthey do not already have a passkey and do not have a password.\n\n\t\t\t\t\t\tIf passkeys are also conditionally acquired on login then users are given a choice as to what\n\t\t\t\t\t\ttype of credential to register.",
            "never": "Indicates that users are never prompted to create a passkey on login."
          }
        },
        "attestation_preference": {
          "type": "string",
          "enum": [
            "direct",
            "indirect",
            "none"
          ],
          "description": "`attestation_preference` is used to specify the preference regarding attestation conveyance during\ncredential generation.",
          "default": "direct",
          "meta:enum": {
            "direct": "Indicates that the Relying Party wants to receive the attestation statement as generated by\n\t\t\t\t\tthe authenticator.",
            "indirect": "Indicates that the Relying Party prefers an attestation conveyance yielding verifiable\n\t\t\t\t\tattestation statements, but allows the client to decide how to obtain such attestation statements.",
            "none": "Indicates that the Relying Party is not interested in authenticator attestation."
          }
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether users can create or authenticate with passkeys.",
          "default": true
        },
        "limit": {
          "type": "integer",
          "description": "`limit` defines the maximum number of passkeys a user can have.",
          "default": 10
        },
        "optional": {
          "type": "boolean",
          "description": "`optional` determines whether users must create a passkey when prompted. The last remaining passkey cannot be\ndeleted if passkeys are required (`optional: false`).\n\nIt also takes part in determining the order of password and passkey acquisition\non login and registration (see also `acquire_on_login` and `acquire_on_registration`): if one credential type is\nrequired (`optional: false`) then that one takes precedence, i.e. is acquired first.",
          "default": true
        },
        "user_verification": {
          "type": "string",
          "enum": [
            "required",
            "preferred",
            "discouraged"
          ],
          "description": "`user_verification` specifies the requirements regarding local authorization with an authenticator through\n various authorization gesture modalities; for example, through a touch plus pin code,\n password entry, or biometric recognition.\n\nThe setting applies to both WebAuthn registration and authentication ceremonies.",
          "default": "preferred",
          "meta:enum": {
            "discouraged": "Indicates that no user verification should be performed.",
            "preferred": "Indicates that user verification is preferred but will not fail the operation if no\n\t\t\t\t\t\tuser verification was performed.",
            "required": "Indicates that user verification is always required."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Password": {
      "properties": {
        "acquire_on_registration": {
          "type": "string",
          "enum": [
            "always",
            "conditional",
            "never"
          ],
          "description": "`acquire_on_registration` configures how users are prompted creating a password on registration.",
          "default": "always",
          "meta:enum": {
            "always": "Indicates that users are always prompted to create a password on registration.",
            "conditional": "Indicates that users are prompted to create a password on registration as long as the user does\n\t\t\t\t\t\tnot have a passkey.\n\n\t\t\t\t\t\tIf passkeys are also conditionally acquired on registration, then users are given a choice as\n\t\t\t\t\t\tto what type of credential to register.",
            "never": "Indicates that users are never prompted to create a password on registration."
          }
        },
        "acquire_on_login": {
          "type": "string",
          "enum": [
            "always",
            "conditional",
            "never"
          ],
          "description": "`acquire_on_login` configures how users are prompted creating a password on login.",
          "default": "never",
          "meta:enum": {
            "always": "Indicates that users are always prompted to create a password on login\n\t\t\t\t\tprovided that they do not already have a password.",
            "conditional": "Indicates that users are prompted to create a password on login provided that\n\t\t\t\t\t\tthey do not already have a password and do not have a passkey.\n\n\t\t\t\t\t\tIf passkeys are also conditionally acquired on login then users are given a choice as to what\n\t\t\t\t\t\ttype of credential to register.",
            "never": "Indicates that users are never prompted to create a password on login."
          }
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether passwords are enabled or disabled.",
          "default": true
        },
        "min_length": {
          "type": "integer",
          "description": "`min_length` determines the minimum password length.",
          "default": 8
        },
        "min_password_length": {
          "type": "integer",
          "description": "Deprecated. Use `min_length` instead.",
          "default": 8
        },
        "optional": {
          "type": "boolean",
          "description": "`optional` determines whether users must set a password when prompted. The password cannot be deleted if\npasswords are required (`optional: false`).\n\nIt also takes part in determining the order of password and passkey acquisition\non login and registration (see also `acquire_on_login` and `acquire_on_registration`): if one credential type is\nrequired (`optional: false`) then that one takes precedence, i.e. is acquired first.",
          "default": false
        },
        "recovery": {
          "type": "boolean",
          "description": "`recovery` determines whether users can start a recovery process, e.g. in case of a forgotten password.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "RateLimiter": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` controls whether rate limiting is enabled or disabled.",
          "default": true
        },
        "store": {
          "type": "string",
          "enum": [
            "in_memory",
            "redis"
          ],
          "description": "`store` sets the store for the rate limiter. When you have multiple instances of Hanko running, it is recommended to use\n the `redis` store because otherwise your instances each have their own states.",
          "default": "in_memory"
        },
        "redis_config": {
          "$ref": "#/$defs/RedisConfig",
          "description": "`redis_config` configures connection to a redis instance.\nRequired if `store` is set to `redis`"
        },
        "passcode_limits": {
          "$ref": "#/$defs/RateLimits",
          "description": "`passcode_limits` controls rate limits for passcode operations."
        },
        "password_limits": {
          "$ref": "#/$defs/RateLimits",
          "description": "`password_limits` controls rate limits for password login operations."
        },
        "token_limits": {
          "$ref": "#/$defs/RateLimits",
          "description": "`token_limits` controls rate limits for token exchange operations."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "RateLimits": {
      "properties": {
        "tokens": {
          "type": "integer",
          "description": "`tokens` determines how many operations/requests can occur in the given `interval`.",
          "default": 3
        },
        "interval": {
          "type": "string",
          "description": "`interval` determines when to reset the token interval.\nIt must be a (possibly signed) sequence of decimal\nnumbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".",
          "default": "1m"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "tokens",
        "interval"
      ]
    },
    "RedisConfig": {
      "properties": {
        "address": {
          "type": "string",
          "description": "`address` is the address of the redis instance in the form of `host[:port][/database]`."
        },
        "password": {
          "type": "string",
          "description": "`password` is the password for the redis instance."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "address"
      ]
    },
    "RelyingParty": {
      "properties": {
        "display_name": {
          "type": "string",
          "description": "`display_name` is the service's name that some WebAuthn Authenticators will display to the user during registration\nand authentication ceremonies.",
          "default": "Hanko Authentication Service"
        },
        "id": {
          "type": "string",
          "description": "`id` is the [effective domain](https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-effective-domain)\nthe passkey/WebAuthn credentials will be bound to.",
          "default": "localhost"
        },
        "origins": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "minItems": 1,
          "description": "`origins` is a list of origins for which passkeys/WebAuthn credentials will be accepted by the server. Must\ninclude the protocol and can only be the effective domain, or a registrable domain suffix of the effective\ndomain, as specified in the [`id`](#id). Except for `localhost`, the protocol **must** always be `https` for\npasskeys/WebAuthn to work. IP Addresses will not work.\n\nFor an Android application the origin must be the base64 url encoded SHA256 fingerprint of the signing\ncertificate.",
          "default": [
            "http://localhost:8888"
          ]
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "RelyingParty webauthn settings for your application using hanko."
    },
    "SMTP": {
      "properties": {
        "host": {
          "type": "string",
          "default": "localhost"
        },
        "port": {
          "type": "string",
          "default": "465"
        },
        "user": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "SMTP Server Settings for sending passcodes"
    },
    "Saml": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether the SAML API endpoints are available.",
          "default": false
        },
        "endpoint_url": {
          "type": "string",
          "description": "`endpoint` is URL at which the SAML endpoints like metadata, callback, etc. are available\n(e.g. `{YOUR_BACKEND_INSTANCE}/api`).\n\nWill be provided as metadata for IdP."
        },
        "audience_uri": {
          "type": "string",
          "description": "`audience_uri` determines the intended recipient or audience for the SAML Assertion."
        },
        "default_redirect_url": {
          "type": "string",
          "description": "`default_redirect_url` is the URL to redirect to in case of errors or when no `allowed_redirect_url` is provided."
        },
        "allowed_redirect_urls": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "`allowed_redirect_urls` is a list of URLs the backend is allowed to redirect to after third party sign-in was\nsuccessful.\n\nSupports wildcard matching through globbing. e.g. `https://*.example.com` will allow `https://foo.example.com`\nand `https://bar.example.com` to be accepted.\n\nGlobbing is also supported for paths, e.g. `https://foo.example.com/*` will match `https://foo.example.com/page1`\nand `https://foo.example.com/page2`.\n\nA double asterisk (`**`) acts as a \"super\"-wildcard/match-all.\n\nSee [here](https://pkg.go.dev/github.com/gobwas/glob#Compile) for more on globbinh."
        },
        "options": {
          "$ref": "#/$defs/Options",
          "title": "options",
          "description": "`options` allows setting optional features for service provider operations."
        },
        "identity_providers": {
          "items": {
            "$ref": "#/$defs/IdentityProvider"
          },
          "type": "array",
          "description": "`identity_providers` is a list of SAML identity providers."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Secrets": {
      "properties": {
        "keys": {
          "items": {
            "type": "string",
            "minLength": 16,
            "title": "keys"
          },
          "type": "array",
          "minItems": 1,
          "description": "`keys` are used to en- and decrypt the JWKs which get used to sign the JWTs issued by the API.\nFor every key a JWK is generated, encrypted with the key and persisted in the database.\n\nYou can use this list for key rotation: add a new key to the beginning of the list and the corresponding\nJWK will then be used for signing JWTs. All tokens signed with the previous JWK(s) will still\nbe valid until they expire. Removing a key from the list does not remove the corresponding\ndatabase record. If you remove a key, you also have to remove the database record, otherwise\napplication startup will fail."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Server": {
      "properties": {
        "public": {
          "$ref": "#/$defs/ServerSettings",
          "title": "public",
          "description": "`public` contains the server configuration for the public API."
        },
        "admin": {
          "$ref": "#/$defs/ServerSettings",
          "title": "admin",
          "description": "`admin` contains the server configuration for the admin API."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ServerSettings": {
      "properties": {
        "address": {
          "type": "string",
          "description": "`address` is the address of the server to listen on in the form of host:port.\n\nSee [net.Dial](https://pkg.go.dev/net#Dial) for details of the address format."
        },
        "cors": {
          "$ref": "#/$defs/Cors",
          "title": "cors",
          "description": "`cors` contains configuration options regarding Cross-Origin-Resource-Sharing."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ServerSide": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether server-side sessions are enabled.\n\nNOTE: When enabled the session endpoint must be used in order to check if a session is still valid.",
          "default": false
        },
        "limit": {
          "type": "integer",
          "description": "`limit` determines the maximum number of server-side sessions a user can have. When the limit is exceeded,\nolder sessions are invalidated.",
          "default": 100
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Service": {
      "properties": {
        "name": {
          "type": "string",
          "description": "`name` determines the name of the service.\nThis value is used, e.g. in the subject header of outgoing emails."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Session": {
      "properties": {
        "audience": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "`audience` is a list of strings that identifies the recipients that the JWT is intended for.\nThe audiences are placed in the `aud` claim of the JWT.\nIf not set, it defaults to the value of the`webauthn.relying_party.id` configuration parameter."
        },
        "cookie": {
          "$ref": "#/$defs/Cookie",
          "description": "`cookie` contains configuration for the session cookie issued on successful registration or login."
        },
        "enable_auth_token_header": {
          "type": "boolean",
          "description": "`enable_auth_token_header` determines whether a session token (JWT) is returned in an `X-Auth-Token`\nheader after a successful authentication. This option should be set to `true` if API and client applications\nrun on different domains.",
          "default": false
        },
        "issuer": {
          "type": "string",
          "description": "`issuer` is a string that identifies the principal (human user, an organization, or a service)\nthat issued the JWT. Its value is set in the `iss` claim of a JWT."
        },
        "lifespan": {
          "type": "string",
          "description": "`lifespan` determines the maximum duration for which a session token (JWT) is valid. It must be a (possibly signed) sequence of decimal\nnumbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".",
          "default": "12h"
        },
        "server_side": {
          "$ref": "#/$defs/ServerSide",
          "description": "`server_side` contains configuration for server-side sessions."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "server_side"
      ]
    },
    "ThirdParty": {
      "properties": {
        "providers": {
          "$ref": "#/$defs/ThirdPartyProviders",
          "title": "providers",
          "description": "`providers` contains the configurations for the available OAuth/OIDC identity providers."
        },
        "redirect_url": {
          "type": "string",
          "description": "`redirect_url` is the URL the third party provider redirects to with an authorization code. Must consist of the base URL\nof your running Hanko backend instance and the `callback` endpoint of the API,\ni.e. `{YOUR_BACKEND_INSTANCE}/thirdparty/callback.`\n\nRequired if any of the [`providers`](#providers) are `enabled`.",
          "examples": [
            "https://yourinstance.com/thirdparty/callback"
          ]
        },
        "error_redirect_url": {
          "type": "string",
          "description": "`error_redirect_url` is the URL the backend redirects to if an error occurs during third party sign-in.\nErrors are provided as 'error' and 'error_description' query params in the redirect location URL.\n\nWhen using the Hanko web components it should be the URL of the page that embeds the web component such that\nerrors can be processed properly by the web component.\n\nYou do not have to add this URL to the 'allowed_redirect_urls', it is automatically included when validating\nredirect URLs.\n\nRequired if any of the [`providers`](#providers) are `enabled`. Must not have trailing slash."
        },
        "default_redirect_url": {
          "type": "string",
          "description": "`default_redirect_url` is the URL the backend redirects to after it successfully verified\nthe response from any third party provider.\n\nMust not have trailing slash."
        },
        "allowed_redirect_urls": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "`allowed_redirect_urls` is a list of URLs the backend is allowed to redirect to after third party sign-in was\nsuccessful.\n\nSupports wildcard matching through globbing. e.g. `https://*.example.com` will allow `https://foo.example.com`\nand `https://bar.example.com` to be accepted.\n\nGlobbing is also supported for paths, e.g. `https://foo.example.com/*` will match `https://foo.example.com/page1`\nand `https://foo.example.com/page2`.\n\nA double asterisk (`**`) acts as a \"super\"-wildcard/match-all.\n\nSee [here](https://pkg.go.dev/github.com/gobwas/glob#Compile) for more on globbing.\n\nMust not be empty if any of the [`providers`](#providers) are `enabled`. URLs in the list must not have a trailing slash."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ThirdPartyProvider": {
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "client_id",
          "secret"
        ]
      },
      "else": {
        "required": [
          "enabled"
        ]
      },
      "properties": {
        "allow_linking": {
          "type": "boolean",
          "description": "`allow_linking` indicates whether existing accounts can be automatically linked with this provider.\n\nLinking is based on matching one of the email addresses of an existing user account with the (primary)\nemail address of the third party provider account."
        },
        "client_id": {
          "type": "string",
          "description": "`client_id` is the ID of the OAuth/OIDC client. Must be obtained from the provider.\n\nRequired if the provider is `enabled`."
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether this provider is enabled.",
          "default": false
        },
        "secret": {
          "type": "string",
          "description": "`secret` is the client secret for the OAuth/OIDC client. Must be obtained from the provider.\n\nRequired if the provider is `enabled`."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "provider"
    },
    "ThirdPartyProviders": {
      "properties": {
        "apple": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`apple` contains the provider configuration for Apple."
        },
        "discord": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`discord` contains the provider configuration for Discord."
        },
        "github": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`github` contains the provider configuration for GitHub."
        },
        "google": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`google` contains the provider configuration for Google."
        },
        "linkedin": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`linkedin` contains the provider configuration for LinkedIn."
        },
        "microsoft": {
          "$ref": "#/$defs/ThirdPartyProvider",
          "description": "`microsoft` contains the provider configuration for Microsoft."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Username": {
      "properties": {
        "acquire_on_login": {
          "type": "boolean",
          "description": "`acquire_on_login` determines whether users, provided that they do not already have set a username,\n\tare prompted to provide a username on login.",
          "default": true
        },
        "acquire_on_registration": {
          "type": "boolean",
          "description": "`acquire_on_registration` determines whether users are prompted to provide a username on registration.",
          "default": true
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` determines whether users can set a unique username.\n\nUsernames can contain letters (a-z,A-Z), numbers (0-9), and underscores.",
          "default": false
        },
        "max_length": {
          "type": "integer",
          "description": "`max_length` specifies the maximum allowed length of a username.",
          "default": 32
        },
        "min_length": {
          "type": "integer",
          "description": "`min_length` specifies the minimum length of a username.",
          "default": 3
        },
        "optional": {
          "type": "boolean",
          "description": "`optional` determines whether users must provide a username when prompted. The username can only be changed but\nnot deleted if usernames are required (`optional: false`).",
          "default": true
        },
        "use_as_login_identifier": {
          "type": "boolean",
          "description": "`use_as_login_identifier` determines whether usernames, if enabled, can be used for logging in.",
          "default": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "WebauthnSettings": {
      "properties": {
        "relying_party": {
          "$ref": "#/$defs/RelyingParty",
          "title": "relying_party"
        },
        "timeout": {
          "type": "integer",
          "description": "Deprecated, use `timeouts` instead.",
          "default": 60000
        },
        "timeouts": {
          "$ref": "#/$defs/WebauthnTimeouts",
          "title": "timeouts",
          "description": "`timeouts` specifies the timeouts for passkey/WebAuthn registration and login."
        },
        "user_verification": {
          "type": "string",
          "enum": [
            "required",
            "preferred",
            "discouraged"
          ],
          "description": "Deprecated, use `passkey.user_verification` instead",
          "default": "preferred"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "WebauthnSettings defines the settings for the webauthn authentication mechanism"
    },
    "WebauthnTimeouts": {
      "properties": {
        "registration": {
          "type": "integer",
          "description": "`registration` determines the time, in milliseconds, that the client is willing to wait for the credential\ncreation request to the WebAuthn API to complete.",
          "default": 600000
        },
        "login": {
          "type": "integer",
          "description": "`login` determines the time, in milliseconds, that the client is willing to wait for the credential\n request to the WebAuthn API to complete.",
          "default": 600000
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Webhook": {
      "properties": {
        "callback": {
          "type": "string",
          "description": "`callback` specifies the URL to which the change data will be sent."
        },
        "events": {
          "$ref": "#/$defs/Events",
          "items": {
            "type": "string",
            "enum": [
              "user",
              "user.create",
              "user.delete",
              "user.update",
              "user.update.email",
              "user.update.email.create",
              "user.update.email.delete",
              "user.update.email.primary",
              "email.send"
            ],
            "title": "events",
            "meta:enum": {
              "email.send": "Triggers on: an email was sent or should be sent",
              "user": "Triggers on: user creation, user deletion, user update, email creation, email deletion, change of primary email",
              "user.create": "Triggers on: user creation",
              "user.delete": "Triggers on: user deletion",
              "user.update": "Triggers on: user update, email creation, email deletion, change of primary email",
              "user.update.email": "Triggers on: email creation, email deletion, change of primary email",
              "user.update.email.create": "Triggers on: email creation",
              "user.update.email.delete": "Triggers on: email deletion",
              "user.update.email.primary": "Triggers on: change of primary email"
            }
          },
          "title": "events",
          "description": "`events` is a list of events this hook listens for."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "hooks"
    },
    "WebhookSettings": {
      "properties": {
        "allow_time_expiration": {
          "type": "boolean",
          "description": "`allow_time_expiration` determines whether webhooks are disabled when unused for 30 days\n(only for database webhooks).",
          "default": false
        },
        "enabled": {
          "type": "boolean",
          "description": "`enabled` enables the webhook feature.",
          "default": false
        },
        "hooks": {
          "$ref": "#/$defs/Webhooks",
          "title": "hooks",
          "description": "`hooks` is a list of Webhook configurations.\n\nWhen using environment variables the value for the `WEBHOOKS_HOOKS` key must be specified in the following\nformat:\n`{\"callback\":\"http://app.com/usercb\",\"events\":[\"user\"]};{\"callback\":\"http://app.com/emailcb\",\"events\":[\"email.send\"]}`"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Webhooks": {
      "items": {
        "$ref": "#/$defs/Webhook"
      },
      "type": "array"
    }
  },
  "title": "Config"
}
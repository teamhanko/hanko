package actions

import (
	"encoding/base64"
	"errors"
	"fmt"
	"github.com/go-webauthn/webauthn/protocol"
	webauthnLib "github.com/go-webauthn/webauthn/webauthn"
	"github.com/gobuffalo/pop/v6"
	"github.com/gofrs/uuid"
	"github.com/labstack/echo/v4"
	"github.com/teamhanko/hanko/backend/config"
	"github.com/teamhanko/hanko/backend/dto/intern"
	"github.com/teamhanko/hanko/backend/flow_api_basic_construct/common"
	"github.com/teamhanko/hanko/backend/flowpilot"
	"github.com/teamhanko/hanko/backend/persistence"
	"github.com/teamhanko/hanko/backend/persistence/models"
	"strings"
	"time"
)

func NewSendWAAssertionResponse(cfg config.Config, persister persistence.Persister, wa *webauthnLib.WebAuthn, httpContext echo.Context) SendWAAssertionResponse {
	return SendWAAssertionResponse{
		cfg,
		persister,
		wa,
		httpContext,
	}
}

type SendWAAssertionResponse struct {
	cfg         config.Config
	persister   persistence.Persister
	wa          *webauthnLib.WebAuthn
	httpContext echo.Context
}

func (a SendWAAssertionResponse) GetName() flowpilot.ActionName {
	return common.ActionSendWAAssertionResponse
}

func (a SendWAAssertionResponse) GetDescription() string {
	return "Send the result which was generated by using a webauthn credential."
}

func (a SendWAAssertionResponse) Initialize(c flowpilot.InitializationContext) {
	webAuthnAvailable := c.Stash().Get("webauthn_available").Bool()
	if !webAuthnAvailable {
		c.SuspendAction()
	}

	c.AddInputs(flowpilot.JSONInput("assertion_response").Required(true).Persist(false))
}

func (a SendWAAssertionResponse) Execute(c flowpilot.ExecutionContext) error {
	if valid := c.ValidateInputData(); !valid {
		return c.ContinueFlowWithError(c.GetCurrentState(), flowpilot.ErrorFormDataInvalid)
	}

	assertionResponse := c.Input().Get("assertion_response").String()
	credentialAssertionData, err := protocol.ParseCredentialRequestResponseBody(strings.NewReader(assertionResponse))

	if err != nil {
		return c.ContinueFlowWithError(c.GetCurrentState(), flowpilot.ErrorFormDataInvalid.Wrap(fmt.Errorf("failed to parse assertion response: %w", err)))
	}

	sessionDataId, err := uuid.FromString(c.Stash().Get("webauthn_session_data_id").String())
	if err != nil {
		return err
	}
	sessionDataModel, err := a.persister.GetWebauthnSessionDataPersister().Get(sessionDataId)
	if err != nil {
		return err
	}

	userId, err := uuid.FromBytes(credentialAssertionData.Response.UserHandle)
	if err != nil {
		return fmt.Errorf("failed to parse user id from user handle: %w", err)
	}

	userModel, err := a.persister.GetUserPersister().Get(userId)
	if err != nil {
		return fmt.Errorf("failed to fetch user from db: %w", err)
	}

	if userModel == nil {
		return c.ContinueFlowWithError(c.GetErrorState(), flowpilot.ErrorTechnical.Wrap(errors.New("user does not exist")))
	}

	discoverableUserHandler := func(rawID, userHandle []byte) (webauthnLib.User, error) {
		return userModel, nil
	}

	sessionData := intern.WebauthnSessionDataFromModel(sessionDataModel)

	credential, err := a.wa.ValidateDiscoverableLogin(discoverableUserHandler, *sessionData, credentialAssertionData)
	if err != nil {
		return c.ContinueFlowWithError(c.GetCurrentState(), common.ErrorPasskeyInvalid.Wrap(fmt.Errorf("failed to validate discoverable login: %w", err)))
	}

	var credentialModel *models.WebauthnCredential
	for i := range userModel.WebauthnCredentials {
		if userModel.WebauthnCredentials[i].ID == base64.RawURLEncoding.EncodeToString(credential.ID) {
			credentialModel = &userModel.WebauthnCredentials[i]
			break
		}
	}

	err = a.persister.Transaction(func(tx *pop.Connection) error {
		if credentialModel != nil {
			now := time.Now().UTC()
			flags := credentialAssertionData.Response.AuthenticatorData.Flags

			credentialModel.LastUsedAt = &now
			credentialModel.BackupState = flags.HasBackupState()
			credentialModel.BackupEligible = flags.HasBackupEligible()

			txErr := a.persister.GetWebauthnCredentialPersisterWithConnection(tx).Update(*credentialModel)
			if txErr != nil {
				return fmt.Errorf("failed to update webauthn credential: %w", txErr)
			}
		}

		txErr := a.persister.GetWebauthnSessionDataPersisterWithConnection(tx).Delete(*sessionDataModel)
		if txErr != nil {
			return fmt.Errorf("failed to delete assertion session data: %w", txErr)
		}

		return nil
	})

	if err != nil {
		return err
	}

	return c.ContinueFlow(common.StateSuccess)
}
